name: "Update Changelog"
description: "Update changelog files for pre-releases by converting Unreleased section to a versioned release"

inputs:
  version:
    description: "Version to use for the release (e.g. 1.21.0)"
    required: true
  main_changelog_path:
    description: "Path to the main CHANGELOG.md file"
    required: false
    default: "CHANGELOG.md"
  vscode_changelog_path:
    description: "Path to the VS Code extension CHANGELOG.md file"
    required: false
    default: "extensions/vscode/CHANGELOG.md"

outputs:
  main_changelog_updated:
    description: "Whether the main changelog was updated"
    value: ${{ steps.update_main.outputs.changes_made }}
  vscode_changelog_updated:
    description: "Whether the VS Code changelog was updated"
    value: ${{ steps.update_vscode.outputs.changes_made || steps.init.outputs.vscode_changelog_updated }}

runs:
  using: "composite"
  steps:
    # Set default value for vscode_changelog_updated
    - name: Initialize outputs
      id: init
      shell: bash
      run: |
        echo "vscode_changelog_updated=false" >> $GITHUB_OUTPUT

    - name: Update main changelog
      id: update_main
      shell: bash
      run: |
        echo "::group::Updating main CHANGELOG.md"

        CHANGELOG_PATH="${{ inputs.main_changelog_path }}"

        # Check if the file exists
        if [ ! -f "$CHANGELOG_PATH" ]; then
          echo "::error::Main changelog file not found at $CHANGELOG_PATH"
          exit 1
        fi

        # Check if there's an [Unreleased] section in the file
        if ! grep -q '\[Unreleased\]' "$CHANGELOG_PATH"; then
          echo "::notice::No [Unreleased] section found in $CHANGELOG_PATH. Creating one."
          
          # Make a backup of the original file
          cp "$CHANGELOG_PATH" "${CHANGELOG_PATH}.bak"
          
          # Add [Unreleased] section after the Changelog header
          awk '/^# Changelog/ { print; print ""; print "## [Unreleased]"; print ""; next } { print }' "${CHANGELOG_PATH}.bak" > "${CHANGELOG_PATH}.new"
          mv "${CHANGELOG_PATH}.new" "$CHANGELOG_PATH"
          
          echo "::notice::Added [Unreleased] section to changelog"
        fi

        VERSION="${{ inputs.version }}"
        DATE=$(date +"%Y-%m-%d")

        # Detect if this is a prerelease based on odd minor version number
        if [[ $VERSION =~ ^([0-9]+)\.([0-9]+)\.([0-9]+)$ ]]; then
          MINOR="${BASH_REMATCH[2]}"
          if (( MINOR % 2 == 1 )); then
            # Odd minor version number means prerelease
            DISPLAY_VERSION="$VERSION prerelease"
            echo "::notice::Detected odd minor version ($MINOR), using prerelease formatting: $DISPLAY_VERSION"
          else
            # Even minor version number means stable release
            DISPLAY_VERSION="$VERSION"
            echo "::notice::Detected even minor version ($MINOR), using standard formatting: $DISPLAY_VERSION"
          fi
        else
          # For non-standard version formats, don't add prerelease suffix
          DISPLAY_VERSION="$VERSION"
          echo "::notice::Non-standard version format, using as-is: $DISPLAY_VERSION"
        fi

        # Create updated changelog content
        # 1. Replace [Unreleased] with the version number
        # 2. Add a new [Unreleased] section at the top

        # Make a backup of the original file if we haven't already
        if [ ! -f "${CHANGELOG_PATH}.bak" ]; then
          cp "$CHANGELOG_PATH" "${CHANGELOG_PATH}.bak"
        fi

        # Replace [Unreleased] with the version (no date)
        # Extract the description content (between "# Changelog" and the first version or Unreleased heading)
        DESCRIPTION=$(awk '
          BEGIN { print_lines = 0; description = "" }
          /^# Changelog/ { print_lines = 1; next }
          /^## \\[/ { print_lines = 0; next }
          print_lines == 1 { description = description $0 "\n" }
          END { print description }
        ' "$CHANGELOG_PATH")

        # Save the existing versions content (everything from first version heading to end)
        VERSIONS=$(awk '
          BEGIN { found=0 }
          /^## \\[[0-9]/ { found=1 }
          found { print }
        ' "$CHANGELOG_PATH")

        # Create a new changelog structure with:
        # 1. Changelog title
        # 2. Description
        # 3. Unreleased section
        # 4. New version section
        # 5. All existing versions
        {
          echo "# Changelog"
          echo -n "$DESCRIPTION"
          echo ""
          echo "## [Unreleased]"
          echo ""
          echo "## [$DISPLAY_VERSION]"
          echo ""
          echo "$VERSIONS"
        } > "${CHANGELOG_PATH}.new"

        # Extract the description content that should remain at the top
        DESCRIPTION=$(awk '
          BEGIN { print_lines = 0; description = "" }
          /^# Changelog/ { print_lines = 1; next }
          /^## \[/ { print_lines = 0; next }
          print_lines == 1 { description = description $0 "\n" }
          END { print description }
        ' "${CHANGELOG_PATH}.bak")

        # Create a new changelog with proper structure
        {
          echo "# Changelog"
          echo ""
          echo "$DESCRIPTION"
          echo "## [Unreleased]"
          echo ""
          # Skip the title and description, start from the first version section (which is now our new version)
          awk 'BEGIN { found=0 } 
            /^## \[[0-9]/ { found=1 } 
            found { print }' "$CHANGELOG_PATH"
        } > "${CHANGELOG_PATH}.new"

        # Ensure we've successfully updated the file
        if ! grep -q "## \[$VERSION\]" "${CHANGELOG_PATH}.new" || ! grep -q "## \[Unreleased\]" "${CHANGELOG_PATH}.new"; then
          echo "::error::Failed to update $CHANGELOG_PATH with new version and unreleased section"
          cat "${CHANGELOG_PATH}.new"
          exit 1
        else
          mv "${CHANGELOG_PATH}.new" "$CHANGELOG_PATH"
          echo "Successfully updated main CHANGELOG.md"
          echo "::notice::Updated [Unreleased] to version [$VERSION] in main CHANGELOG.md"
        fi

        # Clean up all temporary files
        rm -f "${CHANGELOG_PATH}.bak" "${CHANGELOG_PATH}.new.tmp" "${CHANGELOG_PATH}.*-e"
        echo "::endgroup::"

        # Output whether we found changes to make
        if git diff --quiet "$CHANGELOG_PATH"; then
          echo "changes_made=false" >> $GITHUB_OUTPUT
          echo "::notice::No changes were needed in main CHANGELOG.md"
        else
          echo "changes_made=true" >> $GITHUB_OUTPUT
          echo "::notice::Changes made to main CHANGELOG.md"
          
          # Show changes for debugging
          echo "::group::Main CHANGELOG.md changes"
          git diff --color=always "$CHANGELOG_PATH" | cat
          echo "::endgroup::"
        fi

    - name: Copy to VS Code extension changelog
      id: update_vscode
      if: steps.update_main.outputs.changes_made == 'true'
      shell: bash
      run: |
        echo "::group::Updating VS Code extension CHANGELOG.md"

        MAIN_CHANGELOG="${{ inputs.main_changelog_path }}"
        VSCODE_CHANGELOG="${{ inputs.vscode_changelog_path }}"
        VERSION="${{ inputs.version }}"
        DATE=$(date +"%Y-%m-%d")

        # Detect if this is a prerelease based on odd minor version number
        if [[ $VERSION =~ ^([0-9]+)\.([0-9]+)\.([0-9]+)$ ]]; then
          MINOR="${BASH_REMATCH[2]}"
          if (( MINOR % 2 == 1 )); then
            # Odd minor version number means prerelease
            DISPLAY_VERSION="$VERSION prerelease"
            echo "::notice::Detected odd minor version ($MINOR), using prerelease formatting: $DISPLAY_VERSION"
          else
            # Even minor version number means stable release
            DISPLAY_VERSION="$VERSION"
            echo "::notice::Detected even minor version ($MINOR), using standard formatting: $DISPLAY_VERSION"
          fi
        else
          # For non-standard version formats, don't add prerelease suffix
          DISPLAY_VERSION="$VERSION"
          echo "::notice::Non-standard version format, using as-is: $DISPLAY_VERSION"
        fi

        if [ ! -f "$VSCODE_CHANGELOG" ]; then
          echo "::notice::VS Code changelog not found at $VSCODE_CHANGELOG, creating it with basic structure"
          mkdir -p "$(dirname "$VSCODE_CHANGELOG")"
          echo "# Changelog\n\nAll notable changes to the VS Code extension will be documented in this file.\n" > "$VSCODE_CHANGELOG"
        fi

        # Check if the VS Code changelog already has the version we're adding
        if grep -q "## \[$DISPLAY_VERSION\]" "$VSCODE_CHANGELOG"; then
          echo "::notice::Version [$DISPLAY_VERSION] already exists in VS Code changelog, will update content"
        fi

        # Create a backup
        cp "$VSCODE_CHANGELOG" "${VSCODE_CHANGELOG}.bak"

        # Extract description content from VS Code changelog
        VSCODE_DESCRIPTION=$(awk '
          BEGIN { print_lines = 0; description = "" }
          /^# Changelog/ { print_lines = 1; next }
          /^## \\[/ { print_lines = 0; next }
          print_lines == 1 { description = description $0 "\\n" }
          END { print description }
        ' "$VSCODE_CHANGELOG")

        # Save existing versions content from VS Code changelog
        VSCODE_VERSIONS=$(awk '
          BEGIN { found=0 }
          /^## \\[[0-9]/ { found=1 }
          found { print }
        ' "$VSCODE_CHANGELOG")

        # Create VS Code changelog with same structure
        {
          echo "# Changelog"
          echo -n "$VSCODE_DESCRIPTION"
          echo ""
          echo "## [Unreleased]"
          echo ""
          echo "## [$DISPLAY_VERSION]"
          echo ""
          echo "$VSCODE_VERSIONS"
        } > "${VSCODE_CHANGELOG}.new"

        mv "${VSCODE_CHANGELOG}.new" "$VSCODE_CHANGELOG"

        # VS Code changelog is now fully updated with proper format

        echo "::notice::Updated VS Code extension CHANGELOG.md with version [$VERSION]"
        echo "::endgroup::"

        # Output whether we found changes to make
        if git diff --quiet "$VSCODE_CHANGELOG"; then
          echo "changes_made=false" >> $GITHUB_OUTPUT
          echo "::notice::No changes were needed in VS Code extension CHANGELOG.md"
        else
          echo "changes_made=true" >> $GITHUB_OUTPUT
          echo "::notice::Changes made to VS Code extension CHANGELOG.md"
          
          # Show changes for debugging
          echo "::group::VS Code CHANGELOG.md changes"
          git diff --color=always "$VSCODE_CHANGELOG" | cat
          echo "::endgroup::"
        fi

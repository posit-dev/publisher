package pydeps

// Copyright (C) 2023 by Posit Software, PBC.

import (
	"fmt"
	"regexp"
	"slices"
	"strings"

	"github.com/posit-dev/publisher/internal/logging"
	"github.com/posit-dev/publisher/internal/util"
)

type DependencyScanner interface {
	ScanDependencies(base util.AbsolutePath, pythonExecutable string) ([]*PackageSpec, error)
}

type defaultDependencyScanner struct {
	mapper  PackageMapper
	scanner ProjectImportScanner
	log     logging.Logger
}

func NewDependencyScanner(
	log logging.Logger,
) *defaultDependencyScanner {
	return &defaultDependencyScanner{
		mapper:  NewPackageMapper(log),
		scanner: NewProjectImportScanner(log),
		log:     log,
	}
}

func (s *defaultDependencyScanner) ScanDependencies(base util.AbsolutePath, pythonExecutable string) ([]*PackageSpec, error) {
	importNames, err := s.scanner.ScanProjectImports(base)
	if err != nil {
		return nil, err
	}
	mapping, err := s.mapper.GetPackageMap(pythonExecutable)
	if err != nil {
		return nil, err
	}
	specs := []*PackageSpec{}
	for _, importName := range importNames {
		spec, ok := mapping[importName]
		if ok {
			specs = append(specs, spec)
		} else {
			// We didn't see this package installed or in our stdlib list.
			// Assume it's installable under its import name.
			specs = append(specs, &PackageSpec{
				Name:    PackageName(importName),
				Version: "",
			})
		}
	}
	return specs, nil
}

func GetRequirementsFilePath(base util.AbsolutePath) (util.RelativePath, bool, error) {
	filePath := "requirements.txt"
	requirementsFile := base.Join(filePath)
	exists, err := requirementsFile.Exists()
	rel, err := requirementsFile.Rel(base)
	return rel, exists, err
}

func ReadRequirementsFile(path util.AbsolutePath) ([]string, error) {
	content, err := path.ReadFile()
	if err != nil {
		return nil, err
	}
	lines := strings.Split(string(content), "\n")
	commentRE := regexp.MustCompile(`^\s*(#.*)?$`)
	lines = slices.DeleteFunc(lines, func(line string) bool {
		return commentRE.MatchString(line)
	})
	return lines, nil
}

func WriteRequirementsFile(dest util.AbsolutePath, reqs []string, pythonExecutable util.AbsolutePath) error {
	autogenComment := fmt.Sprintf("# requirements.txt auto-generated by Posit Publisher\n# using %s\n", pythonExecutable.String())
	contents := autogenComment + strings.Join(reqs, "\n") + "\n"

	err := dest.WriteFile([]byte(contents), 0666)
	if err != nil {
		return err
	}
	return nil
}

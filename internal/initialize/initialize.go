package initialize

// Copyright (C) 2023 by Posit Software, PBC.

import (
	"fmt"
	"strings"

	"github.com/posit-dev/publisher/internal/config"
	"github.com/posit-dev/publisher/internal/inspect"
	"github.com/posit-dev/publisher/internal/inspect/detectors"
	"github.com/posit-dev/publisher/internal/interpreters"
	"github.com/posit-dev/publisher/internal/logging"
	"github.com/posit-dev/publisher/internal/util"
)

type Initialize interface {
	Init(base util.AbsolutePath, configName string, python util.Path, rExecutable util.Path, log logging.Logger) (*config.Config, error)
	InitIfNeeded(path util.AbsolutePath, configName string, log logging.Logger) error
	GetPossibleConfigs(base util.AbsolutePath, python util.Path, rExecutable util.Path, entrypoint util.RelativePath, log logging.Logger) ([]*config.Config, error)

	normalizeConfig(cfg *config.Config, base util.AbsolutePath, python util.Path, rExecutable util.Path, entrypoint util.RelativePath, log logging.Logger) error
}

type defaultInitialize struct {
	contentTypeDetectorFactory detectors.ContentTypeDetectorFactory
	pythonInspectorFactory     inspect.PythonInspectorFactory
	pythonInterpreterFactory   interpreters.PythonInterpreterFactory
	rInspectorFactory          inspect.RInspectorFactory
	rInterpreterFactory        interpreters.RInterpreterFactory
}

var _ Initialize = &defaultInitialize{}

func NewDefaultInitialize() Initialize {
	return NewInitialize(nil, nil, nil, nil, nil)
}

func NewInitialize(
	contentTypeDetectorFactoryOverride detectors.ContentTypeDetectorFactory,
	pythonInspectorFactoryOverride inspect.PythonInspectorFactory,
	pythonInterpreterFactoryOverride interpreters.PythonInterpreterFactory,
	rInspectorFactoryOverride inspect.RInspectorFactory,
	rInterpreterFactoryOverride interpreters.RInterpreterFactory,
) Initialize {
	initialize := &defaultInitialize{
		contentTypeDetectorFactory: nil,
		pythonInspectorFactory:     nil,
		pythonInterpreterFactory:   nil,
		rInspectorFactory:          nil,
		rInterpreterFactory:        nil,
	}
	if contentTypeDetectorFactoryOverride == nil {
		initialize.contentTypeDetectorFactory = detectors.NewContentTypeDetector
	} else {
		initialize.contentTypeDetectorFactory = contentTypeDetectorFactoryOverride
	}
	if pythonInspectorFactoryOverride == nil {
		initialize.pythonInspectorFactory = inspect.NewPythonInspector
	} else {
		initialize.pythonInspectorFactory = pythonInspectorFactoryOverride
	}
	if pythonInterpreterFactoryOverride == nil {
		initialize.pythonInterpreterFactory = interpreters.NewPythonInterpreter
	} else {
		initialize.pythonInterpreterFactory = pythonInterpreterFactoryOverride
	}
	if rInspectorFactoryOverride == nil {
		initialize.rInspectorFactory = inspect.NewRInspector
	} else {
		initialize.rInspectorFactory = rInspectorFactoryOverride
	}
	if rInterpreterFactoryOverride == nil {
		initialize.rInterpreterFactory = interpreters.NewRInterpreter
	} else {
		initialize.rInterpreterFactory = rInterpreterFactoryOverride
	}
	return initialize
}

var errNoDeployableContent = fmt.Errorf("no deployable content was detected")

const initialComment = ` Configuration file generated by Posit Publisher.
 Please review and modify as needed. See the documentation for more options:
 https://github.com/posit-dev/publisher/blob/main/docs/configuration.md`

func (i *defaultInitialize) inspectProject(base util.AbsolutePath, pythonExecutable util.Path, rExecutable util.Path, log logging.Logger) (*config.Config, error) {
	log.Info("Detecting deployment type and entrypoint...", "path", base.String())
	typeDetector := i.contentTypeDetectorFactory(log)

	configs, err := typeDetector.InferType(base, util.RelativePath{})
	if err != nil {
		return nil, fmt.Errorf("error detecting content type: %w", err)
	}
	if len(configs) == 0 {
		return nil, errNoDeployableContent
	}
	// Command line `init` takes the first detected configuration.
	cfg := configs[0]
	log.Info("Deployment type", "Entrypoint", cfg.Entrypoint, "Type", cfg.Type)

	if cfg.Type == config.ContentTypeUnknown {
		log.Warn("Could not determine content type; creating config file with unknown type", "path", base)
	}
	if cfg.Title == "" {
		// Default title is the name of the project directory.
		cfg.Title = base.Base()
	}

	pythonInspector, err := i.pythonInspectorFactory(base, pythonExecutable, log, i.pythonInterpreterFactory, nil)
	if err != nil {
		log.Debug("Error while creating the Python Inspector", "error", err.Error())
		return nil, err
	}
	needPython, err := pythonInspector.RequiresPython(cfg)
	if err != nil {
		log.Debug("Error while determining Python as a requirement", "error", err.Error())
		return nil, err
	}
	if needPython {
		log.Debug("Determined that Python is required")
		pyConfig, err := pythonInspector.InspectPython()
		if err != nil {
			log.Debug("Error while inspecting to generate a python based configuration", "error", err.Error())
			return nil, err
		}
		cfg.Python = pyConfig
		cfg.Files = append(cfg.Files, fmt.Sprint("/", cfg.Python.PackageFile))
	}

	rInspector, err := i.rInspectorFactory(base, rExecutable, log, i.rInterpreterFactory, nil)
	if err != nil {
		log.Debug("Error while creating the R Inspector", "error", err.Error())
		return nil, err
	}

	needR, err := rInspector.RequiresR(cfg)
	if err != nil {
		log.Debug("Error while determining R as a requirement", "error", err.Error())
		return nil, err
	}
	if needR {
		log.Debug("Determined that R is required")
		rConfig, err := rInspector.InspectR()
		if err != nil {
			log.Debug("Error while inspecting to generate an R based configuration", "error", err.Error())
			return nil, err
		}
		cfg.R = rConfig
		cfg.Files = append(cfg.Files, fmt.Sprint("/", cfg.R.PackageFile))
	}
	cfg.Comments = strings.Split(initialComment, "\n")

	return cfg, nil
}

func (i *defaultInitialize) normalizeConfig(
	cfg *config.Config,
	base util.AbsolutePath,
	pythonExecutable util.Path,
	rExecutable util.Path,
	entrypoint util.RelativePath,
	log logging.Logger,
) error {
	// Usually an entrypoint will be inferred.
	// If not, use the specified entrypoint, or
	// fall back to unknown.
	if cfg.Entrypoint == "" {
		cfg.Entrypoint = entrypoint.String()

		if cfg.Entrypoint == "" {
			cfg.Entrypoint = "unknown"
		}
	}

	log.Info("Possible deployment type", "Entrypoint", cfg.Entrypoint, "Type", cfg.Type)
	if cfg.Title == "" {
		// Default title is the name of the project directory.
		cfg.Title = base.Base()
	}
	// The inspector may populate the file list.
	// If it doesn't, default to just the entrypoint file.
	if len(cfg.Files) == 0 {
		log.Debug("Inspector did not populate files list, defaulting to single file entrypoint", "entrypoint", cfg.Entrypoint)
		cfg.Files = []string{fmt.Sprint("/", cfg.Entrypoint)}
	} else {
		log.Debug("Inspector populate files list", "total_files", len(cfg.Files))
	}

	pythonInspector, err := i.pythonInspectorFactory(base, pythonExecutable, log, i.pythonInterpreterFactory, nil)
	if err != nil {
		log.Debug("Error while creating the Python Inspector", "error", err.Error())
		return err
	}
	needPython, err := pythonInspector.RequiresPython(cfg)
	if err != nil {
		log.Debug("Error while determining Python as a requirement", "error", err.Error())
		return err
	}
	if needPython {
		log.Debug("Determined that Python is required")
		pyConfig, err := pythonInspector.InspectPython()
		if err != nil {
			log.Debug("Error while inspecting to generate a python based configuration", "error", err.Error())
			return err
		}
		cfg.Python = pyConfig
		cfg.Files = append(cfg.Files, fmt.Sprint("/", cfg.Python.PackageFile))
	}

	rInspector, err := i.rInspectorFactory(base, rExecutable, log, i.rInterpreterFactory, nil)
	if err != nil {
		log.Debug("Error while creating the RInspector", "error", err.Error())
		return err
	}
	needR, err := rInspector.RequiresR(cfg)
	if err != nil {
		log.Debug("Error while determining R as a requirement", "error", err.Error())
		return err
	}
	if needR {
		rConfig, err := rInspector.InspectR()
		if err != nil {
			log.Debug("Error while inspecting to generate an R based configuration", "error", err.Error())
			return err
		}
		cfg.R = rConfig
		cfg.Files = append(cfg.Files, fmt.Sprint("/", cfg.R.PackageFile))
	}
	cfg.Comments = strings.Split(initialComment, "\n")

	return nil
}

func (i *defaultInitialize) GetPossibleConfigs(
	base util.AbsolutePath,
	python util.Path,
	rExecutable util.Path,
	entrypoint util.RelativePath,
	log logging.Logger) ([]*config.Config, error) {

	log.Info("Detecting deployment type and entrypoint...", "path", base.String())
	typeDetector := i.contentTypeDetectorFactory(log)
	configs, err := typeDetector.InferType(base, entrypoint)
	if err != nil {
		return nil, fmt.Errorf("error detecting content type: %w", err)
	}

	for _, cfg := range configs {
		err = i.normalizeConfig(cfg, base, python, rExecutable, entrypoint, log)
		if err != nil {
			return nil, err
		}
	}
	return configs, nil
}

func (i *defaultInitialize) Init(base util.AbsolutePath, configName string, pythonExecutable util.Path, rExecutable util.Path, log logging.Logger) (*config.Config, error) {
	if configName == "" {
		configName = config.DefaultConfigName
	}
	cfg, err := i.inspectProject(base, pythonExecutable, rExecutable, log)
	if err != nil {
		return nil, err
	}
	err = i.normalizeConfig(cfg, base, pythonExecutable, rExecutable, util.RelativePath{}, log)
	if err != nil {
		return nil, err
	}
	configPath := config.GetConfigPath(base, configName)
	err = cfg.WriteFile(configPath)
	if err != nil {
		return nil, err
	}
	return cfg, nil
}

// InitIfNeeded runs an auto-initialize if the specified config file does not exist.
func (i *defaultInitialize) InitIfNeeded(path util.AbsolutePath, configName string, log logging.Logger) error {
	configPath := config.GetConfigPath(path, configName)
	exists, err := configPath.Exists()
	if err != nil {
		return err
	}
	if !exists {
		log.Info("Configuration file does not exist; creating it", "path", configPath.String())
		_, err = i.Init(path, configName, util.Path{}, util.Path{}, log)
		if err != nil {
			return err
		}
	}
	return nil
}

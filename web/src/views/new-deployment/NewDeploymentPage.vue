<!-- Copyright (C) 2023 by Posit Software, PBC. -->

<template>
  <NewDeploymentHeader
    v-if="defaultConfig"
    :account-name="accountName"
    :deployment-name="deploymentName"
    :config-error="isConfigurationError(defaultConfig) ? defaultConfig : undefined"
    @deploy="hasDeployed = true"
  />

  <DeploymentSection
    title="Configuration"
    :subtitles="configurationSubTitles"
  >
    <ConfigSettings
      v-if="defaultConfig"
      :config="defaultConfig"
    />
  </DeploymentSection>

  <DeploymentSection
    title="Files"
    :subtitles="fileSubTitles"
  >
    <FileTree />
  </DeploymentSection>
</template>

<script setup lang="ts">
import { useQuasar } from 'quasar';
import { PropType, computed, ref } from 'vue';
import { onBeforeRouteLeave, useRoute, useRouter } from 'vue-router';

import { Configuration, ConfigurationError, isConfigurationError, useApi } from 'src/api';
import { newFatalErrorRouteLocation } from 'src/util/errors';

import ConfigSettings from 'src/components/config/ConfigSettings.vue';
import FileTree from 'src/components/FileTree.vue';
import NewDeploymentHeader from './NewDeploymentHeader.vue';
import DeploymentSection from 'src/components/DeploymentSection.vue';

const route = useRoute();
const router = useRouter();
const hasDeployed = ref(false);
const api = useApi();
const $q = useQuasar();

const configurations = ref<Array<Configuration | ConfigurationError>>([]);

const props = defineProps({
  name: {
    type: [String, Array] as PropType<string | string[]>,
    required: false,
    default: undefined,
  },
  url: {
    type: [String, Array] as PropType<string | string[]>,
    required: false,
    default: undefined,
  },
});

const accountName = computed(() => {
  // route param can be either string | string[]
  if (Array.isArray(route.params.account)) {
    return route.params.account[0];
  }
  return route.params.account;
});

const deploymentName = computed(() => {
  // route query can be either string | string[]
  if (Array.isArray(props.name)) {
    return props.name[0] || undefined;
  }
  return props.name || undefined;
});

const defaultConfig = computed(() => {
  return configurations.value.find((c) => c.configurationName === 'default');
});

const configurationSubTitles = computed(() => {
  return [
    `Using ${defaultConfig.value?.configurationPath}`,
    `The settings present in this file are listed below and will be used during 
      the next deployment of your project.`,
    `Edit this file to add or modify settings which will be applied 
      during this project's next deployment.`,
  ];
});

const fileSubTitles = computed(() => {
  return [
    `The files detected for this project. Unless ignored, these files will be
      uploaded to the server each time you deploy this project.`,
    `NOTE: A .positignore file can be used to indicate which files should
      not be included in your deployments to the server.`,
  ];
});

onBeforeRouteLeave((_to, _from, next) => {
  if (hasDeployed.value) {
    return next();
  }
  $q.dialog({
    title: 'Warning',
    message: 'You have not deployed yet, a deployment has not been created. Are you sure you want to leave?',
    cancel: true,
  }).onOk(() => {
    console.log('OK');
    next();
  })
    .onCancel(() => {
      console.log('CANCEL');
      next(false);
    });
});

async function getConfigurations() {
  try {
    // API Returns:
    // 200 - success
    // 500 - internal server error
    const response = await api.configurations.getAll();
    configurations.value = response.data;
  } catch (error: unknown) {
    router.push(newFatalErrorRouteLocation(error, 'NewDeploymentPage::getConfigurations()'));
  }
}

getConfigurations();
</script>

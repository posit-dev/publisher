# Build and run all tests against in development
default: dev

# Install Cypress dependencies using npm
install:
    npm install

# Build the specified docker image using docker compose
build service:
    docker build -f Dockerfile.base --tag e2ebase --platform linux/amd64 .
    docker compose build "{{service}}"

start service:
    docker compose up -d "{{service}}"

# Stop all services using docker compose
stop:
    docker compose down --volumes --remove-orphans

lint:
    npm run lint

clear-credentials:
    #!/usr/bin/env bash
    set -euo pipefail

    cat <<EOF > e2e-test.connect-credentials
    # File updated and managed by e2e tests. Refrain from updating it manually.

    EOF

dev: 
    #!/usr/bin/env bash
    set -euo pipefail
    
    # check to see if rsconnect-python is available, because if it is not, then the tests fail in weird ways....
    rsconnect version || {
        echo "rsconnect-python is not installed. Did you forget to start your virtual environment in which it is installed?"
        exit 1
    }
    just build-publisher
    just e2e

e2e:
    #!/usr/bin/env bash
    set -euo pipefail

    function cleanup() {
        just clear-credentials
    }
    trap cleanup EXIT

    just clear-credentials
    just install
    just start "connect-publisher-e2e"
    just start "code-server"
    just start-workbench "release"

    # Install the Publisher extension
    VSIX_FILENAME=$(ls -Art ../../dist | grep linux-amd64 | tail -n 1)
    docker compose exec code-server code-server --install-extension "/home/coder/vsix/${VSIX_FILENAME}"
    just install-workbench-extension "release"

    npm run cypress:open

# This will build all of the images, but you can also force a rebuild for one of them
# using the command `docker compose build --no-cache <service-name>` where <service-name> is 
# listed in the docker-compose.yml file ( code-server & connect-publisher-e2e)
# NOTE: `docker compose` will build an image if it is needed and will use the cache, so no real reason to normally do this.`
build-images:
    docker build -f Dockerfile.base --tag e2ebase --platform linux/amd64 .
    just build "connect-publisher-e2e"
    just build "code-server"
    just build-workbench "release"

build-publisher:
    USE_PLATFORM="linux/amd64" just ../../build
    USE_PLATFORM="linux/amd64" just ../../package

old-dev:
    #!/usr/bin/env bash
    set -euo pipefail

    function cleanup() {
        just clear-credentials
    }
    trap cleanup EXIT

    USE_PLATFORM="linux/amd64" just ../../build
    USE_PLATFORM="linux/amd64" just ../../package
    just clear-credentials
    just install
    just build "connect-publisher-e2e"
    just build "code-server"
    just start "connect-publisher-e2e"
    just start "code-server"
    npm run cypress:open


# =====================================================================
# Workbench-specific commands
# These commands use the Workbench services defined in docker-compose.yml
# The Workbench images include the default user: rstudio/rstudio
# =====================================================================

# Pull the Workbench container image
build-workbench service="all":
    #!/usr/bin/env bash
    set -euo pipefail

    # Always remove existing containers first for clean builds
    just remove-workbench "{{ service }}"

    if [ "{{ service }}" = "all" ]; then
        echo "Pulling all Workbench container images..."
        # Use docker compose pull for both services
        docker compose pull workbench-preview workbench-release
        echo "All Workbench images pulled!"
    elif [[ "{{ service }}" = "preview" || "{{ service }}" = "release" ]]; then
        echo "Pulling Workbench {{ service }} container image..."
        docker compose pull workbench-{{ service }}
        echo "Workbench {{ service }} image pulled!"
    else
        echo "Invalid service: {{ service }}"
        echo "Must be either 'preview', 'release', or 'all'"
        exit 1
    fi

# Start a Workbench container
start-workbench service:
    #!/usr/bin/env bash
    set -euo pipefail

    # Validate service name
    if [[ "{{ service }}" != "preview" && "{{ service }}" != "release" ]]; then
        echo "Invalid service: {{ service }}"
        echo "Must be either 'preview' or 'release'"
        exit 1
    fi
    
    # Create directories for volumes if they do not exist
    mkdir -p ./logs/workbench-{{ service }}
    mkdir -p ./licenses
    
    # Check if license file exists and is valid (not just a placeholder)
    if [ ! -s ./licenses/workbench-license.lic ] || [ "$(cat ./licenses/workbench-license.lic | wc -l)" -lt 2 ]; then
        echo "WARNING: Valid Workbench license file not found at ./licenses/workbench-license.lic"
        echo "You must have a valid Workbench license file to use the containers without license errors."
        echo "Please add a valid license file before starting the container."
        echo ""
    fi

    echo "Starting Workbench {{ service }} container..."
    docker compose up -d workbench-{{ service }}
    
    echo "Waiting for container to become healthy..."
    # Docker compose has built-in healthcheck support
    
    # Simple approach: Loop with a counter, no external tools needed
    MAX_ATTEMPTS=180  # 90 seconds (180 * 0.5s) 
    attempts=0
    
    while [ $attempts -lt $MAX_ATTEMPTS ]; do
        if docker compose ps | grep "workbench-{{ service }}" | grep -q "healthy"; then
            echo ""
            echo "✅ Workbench {{ service }} is healthy and ready!"
            break
        fi
        echo -n "."
        sleep 0.5
        attempts=$((attempts + 1))
    done
    
    # Check if we timed out
    if [ $attempts -eq $MAX_ATTEMPTS ]; then
        echo ""
        echo "⚠️ Timed out waiting for container to become healthy"
        echo "Check container logs with: docker logs publisher-e2e.workbench-{{ service }}"
    fi
    echo ""
    
    echo "Access Workbench at: http://localhost:8787"

# Stop a Workbench container
stop-workbench service="all":
    #!/usr/bin/env bash
    set -euo pipefail

    if [ "{{ service }}" = "all" ]; then
        echo "Stopping all Workbench containers..."
        docker compose stop workbench-preview workbench-release 2>/dev/null || true
        echo "All Workbench containers stopped!"
    elif [[ "{{ service }}" = "preview" || "{{ service }}" = "release" ]]; then
        echo "Stopping Workbench {{ service }} container..."
        docker compose stop workbench-{{ service }} 2>/dev/null || true
        echo "Workbench {{ service }} stopped!"
    else
        echo "Invalid service: {{ service }}"
        echo "Must be either 'preview', 'release', or 'all'"
        exit 1
    fi

# Remove Workbench containers to ensure clean builds
remove-workbench service="all":
    #!/usr/bin/env bash
    set -euo pipefail

    # First stop the containers
    just stop-workbench "{{ service }}"
    
    if [ "{{ service }}" = "all" ]; then
        echo "Removing all Workbench containers..."
        docker compose rm -f workbench-preview workbench-release 2>/dev/null || true
        echo "All Workbench containers removed!"
    elif [[ "{{ service }}" = "preview" || "{{ service }}" = "release" ]]; then
        echo "Removing Workbench {{ service }} container..."
        docker compose rm -f workbench-{{ service }} 2>/dev/null || true
        echo "Workbench {{ service }} container removed!"
    else
        echo "Invalid service: {{ service }}"
        echo "Must be either 'preview', 'release', or 'all'"
        exit 1
    fi

# Install Publisher extension in a running Workbench container
install-workbench-extension service:
    #!/usr/bin/env bash
    set -euo pipefail

    # Validate service name
    if [[ "{{ service }}" != "preview" && "{{ service }}" != "release" ]]; then
        echo "Invalid service: {{ service }}"
        echo "Must be either 'preview' or 'release'"
        exit 1
    fi

    echo "Installing Publisher extension in Workbench {{ service }} container..."
    
    # Check if container is running
    if ! docker ps | grep "publisher-e2e.workbench-{{ service }}" | grep -q "Up"; then
        echo "Container publisher-e2e.workbench-{{ service }} is not running."
        echo "Please start it first with: just start-workbench {{ service }}"
        exit 1
    fi   
    
    # Find the VSIX file directly from the mounted volume
    echo "Looking for VSIX file in container..."
    VSIX_FILENAME=$(docker exec publisher-e2e.workbench-{{ service }} bash -c "ls -Art /vsix-tmp | grep linux-amd64 | tail -n 1")

    if [ -z "$VSIX_FILENAME" ]; then
        echo "ERROR: No linux-amd64 Publisher VSIX found in container."
        echo "Contents of /vsix-tmp:"
        docker exec publisher-e2e.workbench-{{ service }} bash -c "ls -la /vsix-tmp"
        exit 1
    fi
    
    echo "Using VSIX: $VSIX_FILENAME"
    
    # Set proper ownership for the VSIX directory and files
    docker exec publisher-e2e.workbench-{{ service }} bash -c "chown -R rstudio:rstudio /vsix-tmp"
    
    # Create the .positron-server directory with proper permissions
    echo "Creating .positron-server directory with proper permissions..."
    docker exec publisher-e2e.workbench-{{ service }} bash -c "mkdir -p /home/rstudio/.positron-server && chown -R rstudio:rstudio /home/rstudio/.positron-server"
    
    # Create logs directory with workbench prefix
    mkdir -p ./logs/workbench-extension
    INSTALL_LOG="./logs/workbench-extension/workbench-extension-installation.log"

    # Run installation command as the rstudio user to ensure proper permissions
    echo "Running installation command..." | tee "$INSTALL_LOG"
    docker exec -u rstudio publisher-e2e.workbench-{{ service }} bash -c "cd /usr/lib/rstudio-server/bin/positron-server && ./bin/positron-server --install-extension /vsix-tmp/$VSIX_FILENAME --force" | tee -a "$INSTALL_LOG" || {
        echo "Installation command failed" | tee -a "$INSTALL_LOG"
        exit 2
    }
    
    # Verify the extension is installed
    echo "Verifying installation..." | tee -a "$INSTALL_LOG"

    MAX_ATTEMPTS=5

    for i in $(seq 1 $MAX_ATTEMPTS); do
        echo "Verification attempt $i/$MAX_ATTEMPTS..." | tee -a "$INSTALL_LOG"

        # Check specifically for version 99.0.0
        EXPECTED_DIR=$(docker exec -u rstudio publisher-e2e.workbench-{{ service }} bash -c "find /home/rstudio/.positron-server/extensions -name 'posit.publisher-99.0.0' -type d" 2>/dev/null || echo "")

        if [ -n "$EXPECTED_DIR" ]; then
            echo "✅ Publisher extension version 99.0.0 successfully installed!" | tee -a "$INSTALL_LOG"
            echo "Found at: $EXPECTED_DIR" | tee -a "$INSTALL_LOG"
            exit 0
        fi

        # If we reach the last attempt, show error and exit
        if [ $i -eq $MAX_ATTEMPTS ]; then
            echo "ERROR: Failed to verify extension installation with version 99.0.0" | tee -a "$INSTALL_LOG"
            echo "Available Publisher versions:" | tee -a "$INSTALL_LOG"
            docker exec -u rstudio publisher-e2e.workbench-{{ service }} bash -c "find /home/rstudio/.positron-server/extensions -name 'posit.publisher-*' -type d" | tee -a "$INSTALL_LOG" || echo "No Publisher versions found" | tee -a "$INSTALL_LOG"
            exit 1
        fi

        echo "Version 99.0.0 not found yet, waiting..." | tee -a "$INSTALL_LOG"
        sleep 2
    done

    # This should not be reached due to the exit statements above
    echo "ERROR: Unexpected end of verification loop" | tee -a "$INSTALL_LOG"
    exit 1
    echo "Note: You may need to restart existing Positron sessions for the changes to take effect."

# Check if publisher extension is installed in workbench-release
# This command is designed to work from any directory (Cypress or command line)
check-extension:
    #!/usr/bin/env bash
    set -euo pipefail

    # Set expected version
    EXPECTED_VERSION="99.0.0"
    mkdir -p ./logs/workbench-extension
    INSTALL_LOG="./logs/workbench-extension/workbench-extension-check.log"

    echo "Checking for publisher extension..." | tee "$INSTALL_LOG"
    docker ps | tee -a "$INSTALL_LOG"

    if ! docker ps | grep "workbench" | grep -q "release"; then
        echo "Container with 'workbench' and 'release' in name is not running" | tee -a "$INSTALL_LOG"
        exit 1
    fi

    EXTENSION_FOUND=$(docker exec -u rstudio publisher-e2e.workbench-release bash -c "find /home/rstudio/.positron-server/extensions -path '*publisher*' -name package.json" 2>/dev/null | grep -c package.json || echo "0")

    echo "Available extension directories:" | tee -a "$INSTALL_LOG"
    docker exec -u rstudio publisher-e2e.workbench-release bash -c "find /home/rstudio/.positron-server/extensions -type d -maxdepth 2" | tee -a "$INSTALL_LOG" || echo "No extensions directory found" | tee -a "$INSTALL_LOG"

    if [ "$EXTENSION_FOUND" -gt "0" ]; then
        echo "Publisher extension is installed, checking version..." | tee -a "$INSTALL_LOG"

        EXPECTED_VERSION_DIR=$(docker exec -u rstudio publisher-e2e.workbench-release bash -c "find /home/rstudio/.positron-server/extensions -name 'posit.publisher-$EXPECTED_VERSION' -type d" 2>/dev/null || echo "")

        echo "Checking for version directory: posit.publisher-$EXPECTED_VERSION" | tee -a "$INSTALL_LOG"

        if [ -n "$EXPECTED_VERSION_DIR" ]; then
            echo "✅ Correct Publisher extension version $EXPECTED_VERSION is installed" | tee -a "$INSTALL_LOG"
            echo "Found at: $EXPECTED_VERSION_DIR" | tee -a "$INSTALL_LOG"
            exit 0
        else
            echo "❌ Expected Publisher extension version $EXPECTED_VERSION not found" | tee -a "$INSTALL_LOG"
            echo "Available Publisher versions:" | tee -a "$INSTALL_LOG"
            docker exec -u rstudio publisher-e2e.workbench-release bash -c "find /home/rstudio/.positron-server/extensions -name 'posit.publisher-*' -type d" | tee -a "$INSTALL_LOG" || echo "No Publisher versions found" | tee -a "$INSTALL_LOG"
            exit 1
        fi
    else
        echo "❌ Publisher extension is NOT installed" | tee -a "$INSTALL_LOG"
        exit 1
    fi

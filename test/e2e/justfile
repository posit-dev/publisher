# Build and run all tests against in development
default: dev

# Install Cypress dependencies using npm
install:
    npm install

# Build the specified docker image using docker compose
build service:
    docker build -f Dockerfile.base --tag e2ebase --platform linux/amd64 .
    docker compose build "{{service}}"

start service:
    docker compose up -d "{{service}}"

# Stop all services using docker compose
stop:
    docker compose down --volumes --remove-orphans

lint:
    npm run lint

clear-credentials:
    #!/usr/bin/env bash
    set -euo pipefail

    cat <<EOF > e2e-test.connect-credentials
    # File updated and managed by e2e tests. Refrain from updating it manually.

    EOF

dev: 
    #!/usr/bin/env bash
    set -euo pipefail
    
    # check to see if rsconnect-python is available, because if it is not, then the tests fail in weird ways....
    rsconnect version || {
        echo "rsconnect-python is not installed. Did you forget to start your virtual environment in which it is installed?"
        exit 1
    }
    just build-publisher
    just e2e

e2e:
    #!/usr/bin/env bash
    set -euo pipefail

    function cleanup() {
        just clear-credentials
    }
    trap cleanup EXIT

    just clear-credentials
    just install
    just start "connect-publisher-e2e"
    just start "code-server"

    # Install the Publisher extension
    VSIX_FILENAME=$(ls -Art ../../dist | grep linux-amd64 | tail -n 1)
    docker compose exec code-server code-server --install-extension "/home/coder/vsix/${VSIX_FILENAME}"

    npm run cypress:open

# This will build all of the images, but you can also force a rebuild for one of them
# using the command `docker compose build --no-cache <service-name>` where <service-name> is 
# listed in the docker-compose.yml file ( code-server & connect-publisher-e2e)
# NOTE: `docker compose` will build an image if it is needed and will use the cache, so no real reason to normally do this.`
build-images:
    docker build -f Dockerfile.base --tag e2ebase --platform linux/amd64 .
    just build "connect-publisher-e2e"
    just build "code-server"
    just build-workbench "release"

build-publisher:
    USE_PLATFORM="linux/amd64" just ../../build
    USE_PLATFORM="linux/amd64" just ../../package

old-dev:
    #!/usr/bin/env bash
    set -euo pipefail

    function cleanup() {
        just clear-credentials
    }
    trap cleanup EXIT

    USE_PLATFORM="linux/amd64" just ../../build
    USE_PLATFORM="linux/amd64" just ../../package
    just clear-credentials
    just install
    just build "connect-publisher-e2e"
    just build "code-server"
    just start "connect-publisher-e2e"
    just start "code-server"
    npm run cypress:open


# =====================================================================
# Workbench-specific commands
# These commands use the Workbench services defined in docker-compose.yml
# The Workbench images include the default user: rstudio/rstudio
# =====================================================================

# Pull the Workbench container image
build-workbench service="all":
    #!/usr/bin/env bash
    set -euo pipefail

    # Always remove existing containers first for clean builds
    just remove-workbench "{{ service }}"

    if [ "{{ service }}" = "all" ]; then
        echo "Pulling all Workbench container images..."
        # Use docker compose pull for both services
        docker compose pull workbench-preview workbench-release
        echo "All Workbench images pulled!"
    elif [[ "{{ service }}" = "preview" || "{{ service }}" = "release" ]]; then
        echo "Pulling Workbench {{ service }} container image..."
        docker compose pull workbench-{{ service }}
        echo "Workbench {{ service }} image pulled!"
    else
        echo "Invalid service: {{ service }}"
        echo "Must be either 'preview', 'release', or 'all'"
        exit 1
    fi

# Start a Workbench container
start-workbench service:
    #!/usr/bin/env bash
    set -euo pipefail

    # Validate service name
    if [[ "{{ service }}" != "preview" && "{{ service }}" != "release" ]]; then
        echo "Invalid service: {{ service }}"
        echo "Must be either 'preview' or 'release'"
        exit 1
    fi
    
    # Create directories for volumes if they do not exist
    mkdir -p ./logs/workbench-{{ service }}
    mkdir -p ./licenses
    
    # Check if license file exists and is valid (not just a placeholder)
    if [ ! -s ./licenses/workbench-license.lic ] || [ "$(cat ./licenses/workbench-license.lic | wc -l)" -lt 2 ]; then
        echo "WARNING: Valid Workbench license file not found at ./licenses/workbench-license.lic"
        echo "You must have a valid Workbench license file to use the containers without license errors."
        echo "Please add a valid license file before starting the container."
        echo ""
    fi

    echo "Starting Workbench {{ service }} container..."
    docker compose up -d workbench-{{ service }}
    
    echo "Waiting for container to become healthy..."
    # Docker compose has built-in healthcheck support
    
    # Simple approach: Loop with a counter, no external tools needed
    MAX_ATTEMPTS=180  # 90 seconds (180 * 0.5s) 
    attempts=0
    
    while [ $attempts -lt $MAX_ATTEMPTS ]; do
        if docker compose ps | grep "workbench-{{ service }}" | grep -q "healthy"; then
            echo ""
            echo "✅ Workbench {{ service }} is healthy and ready!"
            break
        fi
        echo -n "."
        sleep 0.5
        attempts=$((attempts + 1))
    done
    
    # Check if we timed out
    if [ $attempts -eq $MAX_ATTEMPTS ]; then
        echo ""
        echo "⚠️ Timed out waiting for container to become healthy"
        echo "Check container logs with: docker logs publisher-e2e.workbench-{{ service }}"
    fi
    echo ""
    
    echo "Access Workbench at: http://localhost:8787"

# Stop a Workbench container
stop-workbench service="all":
    #!/usr/bin/env bash
    set -euo pipefail

    if [ "{{ service }}" = "all" ]; then
        echo "Stopping all Workbench containers..."
        docker compose stop workbench-preview workbench-release 2>/dev/null || true
        echo "All Workbench containers stopped!"
    elif [[ "{{ service }}" = "preview" || "{{ service }}" = "release" ]]; then
        echo "Stopping Workbench {{ service }} container..."
        docker compose stop workbench-{{ service }} 2>/dev/null || true
        echo "Workbench {{ service }} stopped!"
    else
        echo "Invalid service: {{ service }}"
        echo "Must be either 'preview', 'release', or 'all'"
        exit 1
    fi

# Remove Workbench containers to ensure clean builds
remove-workbench service="all":
    #!/usr/bin/env bash
    set -euo pipefail

    # First stop the containers
    just stop-workbench "{{ service }}"
    
    if [ "{{ service }}" = "all" ]; then
        echo "Removing all Workbench containers..."
        docker compose rm -f workbench-preview workbench-release 2>/dev/null || true
        echo "All Workbench containers removed!"
    elif [[ "{{ service }}" = "preview" || "{{ service }}" = "release" ]]; then
        echo "Removing Workbench {{ service }} container..."
        docker compose rm -f workbench-{{ service }} 2>/dev/null || true
        echo "Workbench {{ service }} container removed!"
    else
        echo "Invalid service: {{ service }}"
        echo "Must be either 'preview', 'release', or 'all'"
        exit 1
    fi

# Install Publisher extension in a running Workbench container
install-workbench-extension service:
    #!/usr/bin/env bash
    set -euo pipefail

    # Validate service name
    if [[ "{{ service }}" != "preview" && "{{ service }}" != "release" ]]; then
        echo "Invalid service: {{ service }}"
        echo "Must be either 'preview' or 'release'"
        exit 1
    fi

    echo "Installing Publisher extension in Workbench {{ service }} container..."
    
    # Check if container is running
    if ! docker ps | grep "publisher-e2e.workbench-{{ service }}" | grep -q "Up"; then
        echo "Container publisher-e2e.workbench-{{ service }} is not running."
        echo "Please start it first with: just start-workbench {{ service }}"
        exit 1
    fi   
    
    # Find the VSIX file directly from the mounted volume
    echo "Looking for VSIX file in container..."
    VSIX_FILENAME=$(docker exec publisher-e2e.workbench-{{ service }} bash -c "ls -Art /home/rstudio/vsix | grep linux-amd64 | tail -n 1")
    
    if [ -z "$VSIX_FILENAME" ]; then
        echo "ERROR: No linux-amd64 Publisher VSIX found in container."
        echo "Contents of /home/rstudio/vsix:"
        docker exec publisher-e2e.workbench-{{ service }} bash -c "ls -la /home/rstudio/vsix"
        exit 1
    fi
    
    echo "Using VSIX: $VSIX_FILENAME"
    
    # Set proper ownership for the VSIX directory and files
    docker exec publisher-e2e.workbench-{{ service }} bash -c "chown -R rstudio:rstudio /home/rstudio/vsix"
    
    # Create the .positron-server directory with proper permissions
    echo "Creating .positron-server directory with proper permissions..."
    docker exec publisher-e2e.workbench-{{ service }} bash -c "mkdir -p /home/rstudio/.positron-server && chown -R rstudio:rstudio /home/rstudio/.positron-server"
    
    # Run installation command as the rstudio user to ensure proper permissions
    docker exec -u rstudio publisher-e2e.workbench-{{ service }} bash -c "cd /usr/lib/rstudio-server/bin/positron-server && ./bin/positron-server --install-extension /home/rstudio/vsix/$VSIX_FILENAME --force"
    
    # Verify the extension is installed
    echo "Verifying installation..."
    for i in {1..30}; do
        if docker exec publisher-e2e.workbench-{{ service }} bash -c "find /home/rstudio/.positron-server/extensions -path '*publisher*' -name package.json" | grep -q publisher; then
            echo "Publisher extension successfully installed!"
            break
        fi
        if [ $i -eq 30 ]; then
            echo "ERROR: Failed to verify extension installation"
            exit 1
        fi
        echo "Waiting for extension verification (attempt $i/30)..."
        sleep 2
    done
    
    # Show the extension details
    echo "Extension details:"
    docker exec publisher-e2e.workbench-{{ service }} bash -c "find /home/rstudio/.positron-server/extensions -path '*publisher*' -name package.json | xargs grep -A 2 version" || true
    
    # Summary message
    echo ""
    echo "✅ Publisher extension successfully installed!"
    echo "Note: You may need to restart existing Positron sessions for the changes to take effect."
